- driver API: drv_ctl_xxx(), drv_read_xxx(), drv_write_xxx() ??
- make overall build system
- deny external access to kernel variables / accessible only by functions.
- produce / consume systicks, start failsafe context-switch kernel superviser
- event subscribe for multiple modules/tasks
- implement archint type (fast integer)
- think about io,ipc,sem,sched be separate modules dynamically inserted in kconsume_events??
- decide if have to use separate work queue for kernel modules
- some kernel work events cannot be consumed immediately? they have to remain stored in queue??
- statistics idle time, load, uptime etc?
- implement semaphore, queue, ipc, io, etc. in kernel.
- task timer - waiting timer - have to implement semapahores before.
- task state IPC_WAIT?
- write about tasks in docs/ how they are ran, fsm, exit/return.
- semaphore owner??
- task destroy should remove task links from task list.
- edit defined flags in headers.
- tickless !!
- Capitalize words in comments like this: Public Functions. / Private Types.
- really needed critical sections on some modules (sem) ??
- check function description for Input/Output Parameters typos.
- remove exited tasks
- Semaphore disabled/enabled by MACRO config
- optimize binary code by creating inline functions for ISR, and other arch dependend code.
- duplicate task names??
- what to do if a task is destroyed but have memory allocated. who will perform the cleanup?
- kernel version, compilation time, etc ?
- analize if this statement: g_kevent_buffer.read_idx >= CONFIG_MAX_EVENTS is less efficient than modulo %
- analize if kget_event should return a pointer to event position in kevent buffer, or it should copy the event as it is now.
- static tasks use static variables for context, dynamic or duplicate tasks should use dynamic memory.
- what happens if a task is waiting for a semaphore and gets killed?? queues in semaphores and other resources.
- implement tasks on linked list over array in order to avoid array defragmenting.
- use klib queue for kernel events?
- implement task return raw status; scheduler taking care.
- implement task_waittask()??
- implement stdio buffering ?
- implement preemption
- implement blocking functions
- latest errno value per task ??
- enabling interrupts in kernel, then disabling next in exec_kernel. Must find a better approach.
